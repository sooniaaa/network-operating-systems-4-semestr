<h1>Makefile</h1>
Компиляция - makefile ab <br>
Запуск программы - ./ab.out <br>
(a - номер лекции, 23 или 4, b -0 номер программы)
<h1>Описание программ</h1>
<br>
Lec2-3, Program1<br><br>
(Example 1, normal memory input)<br>
Enter length of array: 1 <br>
Allocated 4 bytes<br><br>
(Example 2, wrong memory input) <br>
Enter length of array: -1<br>
Error: can't allocate memory: Not enough space<br><br>
Пример программы динамического выделения памяти для массива.<br>
В начале происходит выделение памяти для void (malloc), далее указатель переводится на тип int и делается проверка выделения памяти. В конце память освобождается.<br><br><br>
Lec2-3, Program2 <br><br>
(Example 1)<br>
fd = 3 <br>
called read( 3, c, 10). returned that 0 bytes were read. <br> 
closed the fd. <br><br>
Пример программы чтения данных.<br>
В начале происходит выделение памяти для void (malloc), далее указатель переводится на тип char, далее создается дескриптор и выводится его значение. Происходит чтение 10 байт, после чего записывается терминальный ноль в конец строки и закрывается файл.<BR><BR>
Lec2-3, Program 3<br><br>
(Example 1)<BR>
my pid = 2879, returned pid = 2880<br>
my pid = 2880, returned pid = 0<br><br>
  
Рождение процесса. Системный вызов fork()<br>
После первой функции fork() появляется ребенок процесса. При повторном применении fork() появится 2 ребенка, а каждое дальнейшее ее использование вызовет в 2 раза больше детей. Потом при помощи оператора switch идет проверка, в каком процессе мы находимся.<BR><br>
  
Lec4, Program1<BR><BR>
(Example 1)<BR>
counter = 1<BR>
counter = 3<BR>
counter = 5<BR><BR>
Сигналы. Пример программы<BR>
handler1 и handler2 - 2 обрабатывающие функции, которые принимают на вход наш сигнал с целочислинным типом данных. В первом мы увеличиваем глобальную переменную counter(счетчик) на 1 и отправляем наш сигнал дочернему. В main функции мы обрабатываем пользовательский сигнал. В первый раз первую функцию обработки привязываем сразу к текущему процессу, а если мы окажемся ребенком, то сигнал обрабатывать будет уже 2ая функция. Если мы оказываемся ребенком, то отправляем сигнал родителю.<BR><BR>  
Lec4, Program2  
    
  (Example 1)  
  ./prog2.out unnamed  
  unnamed  
    
  Неименованные каналы. Пример работы программы.  
  Для работы с неименованными каналами используются два дескриптора. Системный вызов pipe записывает два дескриптора с обработкой ошибок. Далее используется системный вызов fork() для получения дочернего процесса, и обрабатываются ошибки. Если cpid равняется 0, то процесс - потомок. Получается что один дескриптор - для чтения, а второй дескриптор - для записи. То есть сообщение передается между процессами с помощью каналов.  
    
  Lec4, Program3  
    
  (Example 1)  
  mypipe is created  
$ echo Aboba > mypipe  
mypipe is opened  
Incomming message (8): Aboba
  
read error: Success  
  
Именованные каналы. Пример работы программы.  
Создаём дескриптор канала и именованный канал с правами доступа для всех. После запускается цикл прослушивания канала. В момент, когда в этот канал попадает сообщение, выводится количество символов, включая 0 конца строки, и само сообщение.
